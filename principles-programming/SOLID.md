# SOLID

SOLID — это набор пяти принципов объектно-ориентированного проектирования, которые помогают разработчикам создавать более гибкий, понятный и поддерживаемый код. Эти принципы были популяризованы Робертом Мартином (также известным как «Чистый Архитектор») и представляют собой акроним, где каждая буква обозначает один из принципов:

S — Single Responsibility Principle (SRP)
Принцип единственной ответственности: Класс должен иметь только одну зону ответственности, то есть должен быть ответственным за выполнение одной задачи или функционала. Это упрощает понимание и поддержку кода, так как каждая часть системы решает только одну задачу.

O — Open/Closed Principle (OCP)
Принцип открытости/закрытости: Модули (классы, функции и т. д.) должны быть открыты для расширения, но закрыты для изменений. Это означает, что существующий код не должен изменяться при добавлении нового функционала; вместо этого, функционал должен расширяться новыми модулями или классами.

L — Liskov Substitution Principle (LSP)
Принцип подстановки Барбары Лисков: Объекты производных классов должны быть заменяемы объектами базового класса без нарушения корректности программы. Это позволяет использовать полиморфизм и наследование, сохраняя при этом корректность работы программы.

I — Interface Segregation Principle (ISP)
Принцип разделения интерфейсов: Интерфейсы должны быть узкими и специализированными. Это означает, что классы не должны реализовывать интерфейсы, методы которых они не используют. Это упрощает изменения и расширения, предотвращая создание «тяжелых» и избыточных интерфейсов.

D — Dependency Inversion Principle (DIP)
Принцип инверсии зависимостей: Модули высшего уровня не должны зависеть от модулей низшего уровня. Оба должны зависеть от абстракций (интерфейсов или абстрактных классов). Это уменьшает связность между компонентами и повышает гибкость системы.

Солид включает пять разных принципов, направленных на улучшение структуры и поддерживаемости кода:

- У функции должна быть только одна зона ответственности (Single Responsibility Principle, SRP).
- Каждый класс или метод должен иметь одну, четко определенную цель и отвечать за выполнение одной задачи. Это облегчает понимание и изменение кода.
- Модули должны быть открыты для расширения, но закрыты для изменений (Open/Closed Principle, OCP).
- Это означает, что существующий код не должен изменяться при добавлении нового функционала. Вместо этого, система должна быть расширена с помощью новых кодов.
- Функция, которая применяет базовые объекты, может использовать их подтипы без дополнительных сложных конструкций (Liskov Substitution Principle, LSP).
- Объекты производных классов должны быть заменяемы объектами базового класса без нарушения корректности программы. Это позволяет использовать полиморфизм для повышения гибкости кода.
- Не переусердствуйте с функциональностью интерфейсов. Разделяйте их на части (Interface Segregation Principle, ISP).
- Интерфейсы должны быть узкими и специализированными, чтобы классы реализовывали только те методы, которые им действительно нужны. Это упрощает изменения и расширения.
- Модули должны зависеть от абстракций (Dependency Inversion Principle, DIP).
- Модули высшего уровня не должны зависеть от модулей низшего уровня. Оба должны зависеть от абстракций (интерфейсов или абстрактных классов). Это уменьшает связность между компонентами и повышает гибкость системы.

Итого:

- Single Responsibility Principle (SRP): Каждый класс и метод должны иметь только одну зону ответственности.
- Open/Closed Principle (OCP): Модули должны быть открыты для расширений, но закрыты для изменений.
- Liskov Substitution Principle (LSP): Подтипы должны быть заменяемы базовыми типами без нарушения корректности.
- Interface Segregation Principle (ISP): Интерфейсы должны быть узкими и специализированными.
- Dependency Inversion Principle (DIP): Модули должны зависеть от абстракций, а не от конкретных реализаций.
